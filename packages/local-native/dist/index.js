"use strict";import{installOptqLocalDatabaseHelper as N,OPTQ_DATABASE_VERSION as E}from"@optq/local";import{open as O}from"@op-engineering/op-sqlite";export default async function p(c,u="optq"){if(!(typeof window.document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"))throw new Error("You can only use `@optq/local-native` in React Native.");class i{constructor(e,t){Object.defineProperty(this,"database",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:t})}static getVersion(e){return e.execute("CREATE TABLE IF NOT EXISTS metadata(id INTEGER PRIMARY KEY, version INTEGER NOT NULL, apiVersion INTEGER);"),e.execute("SELECT version FROM metadata LIMIT 1;").rows?._array?.[0]?.version??0}async getMetadata(){this.database.execute("CREATE TABLE IF NOT EXISTS metadata(id INTEGER PRIMARY KEY, version INTEGER NOT NULL, apiVersion INTEGER);");const e=this.database.execute("SELECT version, apiVersion FROM metadata LIMIT 1;").rows?._array?.[0];return{version:e?.version??0,apiVersion:e?.apiVersion??void 0}}setMetadata(e){this.database.execute("INSERT INTO metadata (id, version, apiVersion) VALUES (0, ?, ?) ON CONFLICT (id) DO UPDATE SET version=excluded.version, apiVersion=excluded.apiVersion;",[e.version,e.apiVersion??null])}static new(e="optq",t){const a=O({name:e,location:t});let s=i.getVersion(a);if(s<1&&(a.execute("CREATE TABLE IF NOT EXISTS requests(id TEXT PRIMARY KEY, apiId TEXT NOT NULL, params JSON, headers JSON, body JSON, respondedAt INT, waitingNetwork BOOLEAN, affectedPredictions JSON);"),a.execute("CREATE TABLE IF NOT EXISTS caches(resId TEXT NOT NULL, hash TEXT NOT NULL, value JSON, respondedAt INT NOT NULL, PRIMARY KEY (resId, hash));"),a.execute("CREATE TABLE IF NOT EXISTS predictions(resId TEXT NOT NULL, hash TEXT NOT NULL, value JSON, PRIMARY KEY (resId, hash));"),s=1),s!==E)throw new Error(`The database version (${s}) is not compatible with the current version (${E}).`);const r=new i(a,e);return r.setMetadata({version:s}),r}async getAllRequests(){return(this.database.execute("SELECT * FROM requests;").rows?._array??[]).map(({params:t,headers:a,body:s,affectedPredictions:r,...n})=>({params:t?JSON.parse(t):void 0,headers:a?JSON.parse(a):void 0,body:s?JSON.parse(s):void 0,affectedPredictions:r?JSON.parse(r):void 0,...n}))}async getAllCaches(){return(this.database.execute("SELECT * FROM caches;").rows?._array??[]).map(({value:t,...a})=>({value:t?JSON.parse(t):void 0,...a}))}async getAllPredictions(){return(this.database.execute("SELECT * FROM predictions;").rows?._array??[]).map(({value:t,...a})=>({value:t?JSON.parse(t):void 0,...a}))}deleteRequest({id:e}){this.database.execute("DELETE FROM requests WHERE id = ?;",[e])}deleteCache({resId:e,hash:t}){this.database.execute("DELETE FROM caches WHERE resId = ? AND hash = ?;",[e,t])}deletePrediction({resId:e,hash:t}){this.database.execute("DELETE FROM predictions WHERE resId = ? AND hash = ?;",[e,t])}upsertRequest({id:e,apiId:t,params:a,headers:s,body:r,respondedAt:n,waitingNetwork:T,affectedPredictions:o}){this.database.execute("INSERT OR REPLACE INTO requests (id, apiId, params, headers, body, respondedAt, waitingNetwork, affectedPredictions) VALUES (?, ?, ?, ?, ?, ?, ?, ?);",[e,t,JSON.stringify(a),JSON.stringify(s),r?JSON.stringify(r):void 0,n,T,o?JSON.stringify(o):void 0])}upsertCache({resId:e,hash:t,value:a,respondedAt:s}){this.database.execute("INSERT INTO caches (resId, hash, value, respondedAt) VALUES (?, ?, ?, ?) ON CONFLICT (resId, hash) DO UPDATE SET value=excluded.value,respondedAt=excluded.respondedAt;",[e,t,JSON.stringify(a),s])}upsertPrediction({resId:e,hash:t,value:a}){this.database.execute("INSERT INTO predictions (resId, hash, value) VALUES (?, ?, ?) ON CONFLICT (resId, hash) DO UPDATE SET value=excluded.value;",[e,t,JSON.stringify(a)])}}const d=i.new(u);return await N(c,d),d}
