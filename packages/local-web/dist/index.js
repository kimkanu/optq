"use strict";import{openDB as y}from"idb";import l from"superjson";import{subscribe as f}from"valtio/vanilla";const w=1;export default async function g(a){if(!("indexedDB"in window)){console.error("This browser doesn't support IndexedDB");return}const i=await y("optq",w,{upgrade(s,o){let r=o;r<1&&(s.objectStoreNames.contains("requests")||s.createObjectStore("requests"),s.objectStoreNames.contains("caches")||s.createObjectStore("caches",{autoIncrement:!0}).createIndex("resId, hash",["resId","hash"]),s.objectStoreNames.contains("predictions")||s.createObjectStore("predictions",{autoIncrement:!0}).createIndex("resId, hash",["resId","hash"]),r=1)}});return await i.getAll("requests").then(async s=>{for(const{respondedAt:o,...r}of s)try{a.requestStore.push({...r,respondedAt:typeof o=="string"?BigInt(o):o})}catch(t){console.error(t)}}),await i.getAll("predictions").then(async s=>{var o;for(const{resId:r,hash:t,value:e}of s)try{(o=a.predictionStore)[r]??(o[r]={}),a.predictionStore[r][t]=l.deserialize(e)}catch(n){console.error(n)}}),await i.getAll("caches").then(async s=>{var o;for(const{resId:r,hash:t,value:e,respondedAt:n}of s)try{(o=a.cacheStore)[r]??(o[r]={}),a.cacheStore[r][t]={value:l.deserialize(e),respondedAt:typeof n=="string"?BigInt(n):n}}catch(c){console.error(c)}}),f(a.requestStore,async s=>{const o=i.transaction("requests","readwrite"),r=o.objectStore("requests");for(const t of s)try{if(t[0]==="delete"){const{id:e}=t[2];await r.delete(e)}else if(t[0]==="set"&&t[1].length===1&&t[1][0]!=="length"&&t[3]){const{id:e}=t[3];await r.delete(e)}}catch(e){console.error(e)}for(const t of a.requestStore)try{const{id:e,apiId:n,params:c,headers:d,body:h,respondedAt:u,waitingNetwork:p,affectedPredictions:S}=l.deserialize(l.serialize(t));if(!p)continue;await r.put({id:e,apiId:n,params:c,headers:d,body:h,waitingNetwork:p,affectedPredictions:S,respondedAt:typeof u=="bigint"?u.toString():u},e)}catch(e){console.error(e)}await o.done}),f(a.predictionStore,async s=>{const o=i.transaction("predictions","readwrite"),r=o.objectStore("predictions");for(const t of s)try{if(t[0]!=="set")continue;const[,e,n]=t;if(e.length!==2)continue;const[c,d]=e,h=await r.index("resId, hash").getKey([c,d]);await r.put({resId:c,hash:d,value:l.serialize(n)},h)}catch(e){console.error(e)}await o.done}),f(a.cacheStore,async s=>{const o=i.transaction("caches","readwrite"),r=o.objectStore("caches");for(const t of s)try{if(t[0]!=="set")continue;const[,e,{value:n,respondedAt:c}]=t;if(e.length!==2)continue;const[d,h]=e,u=await r.index("resId, hash").getKey([d,h]);await r.put({resId:d,hash:h,value:l.serialize(n),respondedAt:typeof c=="bigint"?c.toString():c},u)}catch(e){console.error(e)}await o.done}),i}
